#
# Confluent Schema Registry
# No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
#
# The version of the OpenAPI document: 1.0.0
#
# https://openapi-generator.tech
#
# NOTE: Auto generated by OpenAPI Generator (https://openapi-generator.tech).

cmake_minimum_required (VERSION 3.14)

project(srclient CXX)

# Force -fPIC even if the project is configured for building a static library.
set(CMAKE_POSITION_INDEPENDENT_CODE ON)

set(CXX_STANDARD_REQUIRED ON)
if(NOT CMAKE_CXX_STANDARD)
    if(DEFINED CMAKE_CXX20_STANDARD_COMPILE_OPTION OR
       DEFINED CMAKE_CXX20_EXTENSION_COMPILE_OPTION)
      set(CMAKE_CXX_STANDARD 20)
    elseif(DEFINED CMAKE_CXX17_STANDARD_COMPILE_OPTION OR
           DEFINED CMAKE_CXX17_EXTENSION_COMPILE_OPTION)
      set(CMAKE_CXX_STANDARD 17)
    elseif(DEFINED CMAKE_CXX14_STANDARD_COMPILE_OPTION OR
           DEFINED CMAKE_CXX14_EXTENSION_COMPILE_OPTION)
      set(CMAKE_CXX_STANDARD 14)
    else()
      set(CMAKE_CXX_STANDARD 11)
    endif()
endif()

if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release)
endif()

find_path(AVRO_INCLUDE_DIR avro/Encoder.hh)
get_filename_component(AVRO_ROOT_FIND_DIR ${AVRO_INCLUDE_DIR} DIRECTORY)
find_library(AVRO_LIBRARY avrocpp PATHS "${AVRO_ROOT_FIND_DIR}/lib/" REQUIRED NO_DEFAULT_PATH)

# Create an IMPORTED target for avrocpp
add_library(AvroCpp::avrocpp SHARED IMPORTED)
set_target_properties(AvroCpp::avrocpp PROPERTIES
    IMPORTED_LOCATION "${AVRO_LIBRARY}"
    INTERFACE_INCLUDE_DIRECTORIES "${AVRO_INCLUDE_DIR}"
)

find_package(absl REQUIRED)
find_package(Boost REQUIRED)
find_package(nlohmann_json 3.12.0 REQUIRED)
find_package(Protobuf REQUIRED)

# Help CMake find Homebrew packages on macOS
if(APPLE)
    list(APPEND CMAKE_PREFIX_PATH /opt/homebrew /opt/homebrew/opt/protobuf@3 /usr/local)
endif()

# Function to compile protobuf files in the proto/ directory
function(compile_project_proto_files)
    # Find all .proto files in the proto/ directory only
    file(GLOB_RECURSE PROTO_FILES "${CMAKE_CURRENT_SOURCE_DIR}/proto/*.proto")
    
    if(PROTO_FILES)
        # Create directory for generated files
        set(PROTO_GEN_DIR "${CMAKE_CURRENT_BINARY_DIR}/generated_proto")
        file(MAKE_DIRECTORY ${PROTO_GEN_DIR})
        
        foreach(PROTO_FILE ${PROTO_FILES})
            # Get the file name without extension
            get_filename_component(PROTO_NAME ${PROTO_FILE} NAME_WE)
            
            # Get relative path from proto/ directory for better organization
            file(RELATIVE_PATH PROTO_REL_PATH "${CMAKE_CURRENT_SOURCE_DIR}/proto" "${PROTO_FILE}")
            get_filename_component(PROTO_REL_DIR ${PROTO_REL_PATH} DIRECTORY)
            
            # Generate the output file names in a directory structure that matches the source
            set(PROTO_OUT_DIR "${PROTO_GEN_DIR}/${PROTO_REL_DIR}")
            file(MAKE_DIRECTORY ${PROTO_OUT_DIR})
            set(PROTO_SRCS "${PROTO_OUT_DIR}/${PROTO_NAME}.pb.cc")
            set(PROTO_HDRS "${PROTO_OUT_DIR}/${PROTO_NAME}.pb.h")
            
            # Add custom command to generate C++ files from .proto
            add_custom_command(
                OUTPUT ${PROTO_SRCS} ${PROTO_HDRS}
                COMMAND ${Protobuf_PROTOC_EXECUTABLE}
                ARGS --cpp_out=${PROTO_GEN_DIR}
                     --proto_path=${CMAKE_CURRENT_SOURCE_DIR}/proto
                     ${PROTO_FILE}
                DEPENDS ${PROTO_FILE}
                COMMENT "Generating C++ code from proto/${PROTO_REL_PATH}"
                VERBATIM
            )
            
            # Add generated files to the list
            list(APPEND PROTO_GENERATED_SRCS ${PROTO_SRCS})
            list(APPEND PROTO_GENERATED_HDRS ${PROTO_HDRS})
        endforeach()
        
        # Set variables in parent scope
        set(PROJECT_PROTO_SOURCES ${PROTO_GENERATED_SRCS} PARENT_SCOPE)
        set(PROJECT_PROTO_HEADERS ${PROTO_GENERATED_HDRS} PARENT_SCOPE)
        set(PROJECT_PROTO_INCLUDE_DIR ${PROTO_GEN_DIR} PARENT_SCOPE)
    endif()
endfunction()

# Compile project protobuf files
compile_project_proto_files()

include(GNUInstallDirs)
include(CMakePackageConfigHelpers)

file(GLOB_RECURSE HEADER_FILES "include/*.h")
file(GLOB_RECURSE SOURCE_FILES "src/*.cpp")

# Add generated protobuf files to the source list
if(PROJECT_PROTO_SOURCES)
    list(APPEND SOURCE_FILES ${PROJECT_PROTO_SOURCES})
endif()

add_library(${PROJECT_NAME} ${HEADER_FILES} ${SOURCE_FILES})

target_compile_options(${PROJECT_NAME}
    PRIVATE
        $<$<OR:$<CXX_COMPILER_ID:Clang>,$<CXX_COMPILER_ID:AppleClang>,$<CXX_COMPILER_ID:GNU>>:
            -Wall -Wno-unused-variable -Wno-unused-lambda-capture>
)

target_include_directories(${PROJECT_NAME}
    PUBLIC
        $<BUILD_INTERFACE:${CMAKE_CURRENT_SOURCE_DIR}/include>
        $<INSTALL_INTERFACE:${CMAKE_INSTALL_INCLUDEDIR}>
    PRIVATE
        ${Protobuf_INCLUDE_DIRS}
        $<$<BOOL:${PROJECT_PROTO_INCLUDE_DIR}>:${PROJECT_PROTO_INCLUDE_DIR}>
)

target_link_libraries(${PROJECT_NAME} PUBLIC 
    AvroCpp::avrocpp 
    Boost::headers
    ${Protobuf_LIBRARIES}
    absl::log_internal_log_sink_set
    absl::log_internal_proto
    absl::absl_log
    absl::log_internal_message
    absl::hash
)

configure_package_config_file(${CMAKE_CURRENT_SOURCE_DIR}/Config.cmake.in
    "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake"
    INSTALL_DESTINATION "${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}"
)

install(
    TARGETS ${PROJECT_NAME}
    EXPORT ${PROJECT_NAME}Targets
    LIBRARY DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    ARCHIVE DESTINATION "${CMAKE_INSTALL_LIBDIR}"
    RUNTIME DESTINATION "${CMAKE_INSTALL_BINDIR}"
    INCLUDES DESTINATION "${CMAKE_INSTALL_INCLUDEDIR}"
)

install(
    DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}/include/${PROJECT_NAME}
    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}
)

install(
    FILES "${CMAKE_CURRENT_BINARY_DIR}/${PROJECT_NAME}Config.cmake"
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
)

install(
    EXPORT ${PROJECT_NAME}Targets
    DESTINATION ${CMAKE_INSTALL_LIBDIR}/cmake/${PROJECT_NAME}
)

# Enable testing
enable_testing()
add_subdirectory(test)