/**
* Confluent Schema Registry
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: v1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "srclient/rest/model/Schema.h"
#include "srclient/rest/model/Helpers.h"

#include <sstream>

namespace srclient::rest::model
{

Schema::Schema()
{
    // Optional members are initialized to std::nullopt by default
}

void Schema::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw srclient::rest::model::ValidationException(msg.str());
    }
}

bool Schema::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool Schema::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "Schema" : pathPrefix;

    if (m_References.has_value())
    {
        const std::vector<srclient::rest::model::SchemaReference>& value = m_References.value();
        const std::string currentValuePath = _pathPrefix + ".references";
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const srclient::rest::model::SchemaReference& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                success = value.validate(msg, currentValuePath + ".references") && success;
                i++;
            }
        }
    }
    
    if (m_Metadata.has_value())
    {
        const srclient::rest::model::Metadata& value = m_Metadata.value();
        const std::string currentValuePath = _pathPrefix + ".metadata";
        success = value.validate(msg, currentValuePath + ".metadata") && success;
    }
    
    if (m_Ruleset.has_value())
    {
        const srclient::rest::model::RuleSet& value = m_Ruleset.value();
        const std::string currentValuePath = _pathPrefix + ".ruleset";
        success = value.validate(msg, currentValuePath + ".ruleset") && success;
    }
    
    if (m_RuleSet.has_value())
    {
        const srclient::rest::model::RuleSet& value = m_RuleSet.value();
        const std::string currentValuePath = _pathPrefix + ".ruleSet";
        success = value.validate(msg, currentValuePath + ".ruleSet") && success;
    }
    
    return success;
}

bool Schema::operator==(const Schema& rhs) const
{
    return
        m_Subject == rhs.m_Subject &&
        m_Version == rhs.m_Version &&
        m_Id == rhs.m_Id &&
        m_Guid == rhs.m_Guid &&
        m_SchemaType == rhs.m_SchemaType &&
        m_References == rhs.m_References &&
        m_Metadata == rhs.m_Metadata &&
        m_Ruleset == rhs.m_Ruleset &&
        m_Schema == rhs.m_Schema &&
        m_RuleSet == rhs.m_RuleSet;
}

bool Schema::operator!=(const Schema& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const Schema& o)
{
    j = nlohmann::json::object();
    if(o.m_Subject.has_value())
        j["subject"] = o.m_Subject.value();
    if(o.m_Version.has_value())
        j["version"] = o.m_Version.value();
    if(o.m_Id.has_value())
        j["id"] = o.m_Id.value();
    if(o.m_Guid.has_value())
        j["guid"] = o.m_Guid.value();
    if(o.m_SchemaType.has_value())
        j["schemaType"] = o.m_SchemaType.value();
    if(o.m_References.has_value())
        j["references"] = o.m_References.value();
    if(o.m_Metadata.has_value())
        j["metadata"] = o.m_Metadata.value();
    if(o.m_Ruleset.has_value())
        j["ruleset"] = o.m_Ruleset.value();
    if(o.m_Schema.has_value())
        j["schema"] = o.m_Schema.value();
    if(o.m_RuleSet.has_value())
        j["ruleSet"] = o.m_RuleSet.value();
}

void from_json(const nlohmann::json& j, Schema& o)
{
    if(j.find("subject") != j.end())
    {
        std::string temp;
        j.at("subject").get_to(temp);
        o.m_Subject = temp;
    } 
    if(j.find("version") != j.end())
    {
        int32_t temp;
        j.at("version").get_to(temp);
        o.m_Version = temp;
    } 
    if(j.find("id") != j.end())
    {
        int32_t temp;
        j.at("id").get_to(temp);
        o.m_Id = temp;
    } 
    if(j.find("guid") != j.end())
    {
        std::string temp;
        j.at("guid").get_to(temp);
        o.m_Guid = temp;
    } 
    if(j.find("schemaType") != j.end())
    {
        std::string temp;
        j.at("schemaType").get_to(temp);
        o.m_SchemaType = temp;
    } 
    if(j.find("references") != j.end())
    {
        std::vector<srclient::rest::model::SchemaReference> temp;
        j.at("references").get_to(temp);
        o.m_References = temp;
    } 
    if(j.find("metadata") != j.end())
    {
        srclient::rest::model::Metadata temp;
        j.at("metadata").get_to(temp);
        o.m_Metadata = temp;
    } 
    if(j.find("ruleset") != j.end())
    {
        srclient::rest::model::RuleSet temp;
        j.at("ruleset").get_to(temp);
        o.m_Ruleset = temp;
    } 
    if(j.find("schema") != j.end())
    {
        std::string temp;
        j.at("schema").get_to(temp);
        o.m_Schema = temp;
    } 
    if(j.find("ruleSet") != j.end())
    {
        srclient::rest::model::RuleSet temp;
        j.at("ruleSet").get_to(temp);
        o.m_RuleSet = temp;
    } 
}

std::optional<std::string> Schema::getSubject() const
{
    return m_Subject;
}

void Schema::setSubject(const std::optional<std::string>& value)
{
    m_Subject = value;
}

std::optional<int32_t> Schema::getVersion() const
{
    return m_Version;
}

void Schema::setVersion(const std::optional<int32_t>& value)
{
    m_Version = value;
}

std::optional<int32_t> Schema::getId() const
{
    return m_Id;
}

void Schema::setId(const std::optional<int32_t>& value)
{
    m_Id = value;
}

std::optional<std::string> Schema::getGuid() const
{
    return m_Guid;
}

void Schema::setGuid(const std::optional<std::string>& value)
{
    m_Guid = value;
}

std::optional<std::string> Schema::getSchemaType() const
{
    return m_SchemaType;
}

void Schema::setSchemaType(const std::optional<std::string>& value)
{
    m_SchemaType = value;
}

std::optional<std::vector<srclient::rest::model::SchemaReference>> Schema::getReferences() const
{
    return m_References;
}

void Schema::setReferences(const std::optional<std::vector<srclient::rest::model::SchemaReference>>& value)
{
    m_References = value;
}

std::optional<srclient::rest::model::Metadata> Schema::getMetadata() const
{
    return m_Metadata;
}

void Schema::setMetadata(const std::optional<srclient::rest::model::Metadata>& value)
{
    m_Metadata = value;
}

std::optional<srclient::rest::model::RuleSet> Schema::getRuleset() const
{
    return m_Ruleset;
}

void Schema::setRuleset(const std::optional<srclient::rest::model::RuleSet>& value)
{
    m_Ruleset = value;
}

std::optional<std::string> Schema::getSchema() const
{
    return m_Schema;
}

void Schema::setSchema(const std::optional<std::string>& value)
{
    m_Schema = value;
}

std::optional<srclient::rest::model::RuleSet> Schema::getRuleSet() const
{
    return m_RuleSet;
}

void Schema::setRuleSet(const std::optional<srclient::rest::model::RuleSet>& value)
{
    m_RuleSet = value;
}

} // namespace srclient::rest::model

