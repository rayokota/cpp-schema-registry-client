/**
 * Confluent Schema Registry
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "srclient/rest/model/Rule.h"

#include <sstream>

namespace srclient::rest::model {

NLOHMANN_JSON_SERIALIZE_ENUM(Kind, {{Kind::Transform, "TRANSFORM"},
                                    {Kind::Condition, "CONDITION"}})

NLOHMANN_JSON_SERIALIZE_ENUM(Mode, {{Mode::Upgrade, "UPGRADE"},
                                    {Mode::Downgrade, "DOWNGRADE"},
                                    {Mode::UpDown, "UPDOWN"},
                                    {Mode::Write, "WRITE"},
                                    {Mode::Read, "READ"},
                                    {Mode::WriteRead, "WRITEREAD"}})

Rule::Rule() {
    // Optional members are initialized to std::nullopt by default
}

bool Rule::operator==(const Rule &rhs) const {
    return name_ == rhs.name_ && doc_ == rhs.doc_ && kind_ == rhs.kind_ &&
           mode_ == rhs.mode_ && type_ == rhs.type_ && tags_ == rhs.tags_ &&
           params_ == rhs.params_ && expr_ == rhs.expr_ &&
           onSuccess_ == rhs.onSuccess_ && onFailure_ == rhs.onFailure_ &&
           disabled_ == rhs.disabled_;
}

bool Rule::operator!=(const Rule &rhs) const { return !(*this == rhs); }

void to_json(nlohmann::json &j, const Rule &o) {
    j = nlohmann::json::object();
    if (o.name_.has_value()) j["name"] = o.name_.value();
    if (o.doc_.has_value()) j["doc"] = o.doc_.value();
    if (o.kind_.has_value()) j["kind"] = o.kind_.value();
    if (o.mode_.has_value()) j["mode"] = o.mode_.value();
    if (o.type_.has_value()) j["type"] = o.type_.value();
    if (o.tags_.has_value()) j["tags"] = o.tags_.value();
    if (o.params_.has_value()) j["params"] = o.params_.value();
    if (o.expr_.has_value()) j["expr"] = o.expr_.value();
    if (o.onSuccess_.has_value()) j["onSuccess"] = o.onSuccess_.value();
    if (o.onFailure_.has_value()) j["onFailure"] = o.onFailure_.value();
    if (o.disabled_.has_value()) j["disabled"] = o.disabled_.value();
}

void from_json(const nlohmann::json &j, Rule &o) {
    if (j.find("name") != j.end()) {
        std::string temp;
        j.at("name").get_to(temp);
        o.name_ = temp;
    }
    if (j.find("doc") != j.end()) {
        std::string temp;
        j.at("doc").get_to(temp);
        o.doc_ = temp;
    }
    if (j.find("kind") != j.end()) {
        Kind temp;
        j.at("kind").get_to(temp);
        o.kind_ = temp;
    }
    if (j.find("mode") != j.end()) {
        Mode temp;
        j.at("mode").get_to(temp);
        o.mode_ = temp;
    }
    if (j.find("type") != j.end()) {
        std::string temp;
        j.at("type").get_to(temp);
        o.type_ = temp;
    }
    if (j.find("tags") != j.end()) {
        std::vector<std::string> temp;
        j.at("tags").get_to(temp);
        o.tags_ = temp;
    }
    if (j.find("params") != j.end()) {
        std::map<std::string, std::string> temp;
        j.at("params").get_to(temp);
        o.params_ = temp;
    }
    if (j.find("expr") != j.end()) {
        std::string temp;
        j.at("expr").get_to(temp);
        o.expr_ = temp;
    }
    if (j.find("onSuccess") != j.end()) {
        std::string temp;
        j.at("onSuccess").get_to(temp);
        o.onSuccess_ = temp;
    }
    if (j.find("onFailure") != j.end()) {
        std::string temp;
        j.at("onFailure").get_to(temp);
        o.onFailure_ = temp;
    }
    if (j.find("disabled") != j.end()) {
        bool temp;
        j.at("disabled").get_to(temp);
        o.disabled_ = temp;
    }
}

std::optional<std::string> Rule::getName() const { return name_; }

void Rule::setName(const std::optional<std::string> &value) { name_ = value; }

std::optional<std::string> Rule::getDoc() const { return doc_; }

void Rule::setDoc(const std::optional<std::string> &value) { doc_ = value; }

std::optional<Kind> Rule::getKind() const { return kind_; }

void Rule::setKind(const std::optional<Kind> &value) { kind_ = value; }

std::optional<Mode> Rule::getMode() const { return mode_; }

void Rule::setMode(const std::optional<Mode> &value) { mode_ = value; }

std::optional<std::string> Rule::getType() const { return type_; }

void Rule::setType(const std::optional<std::string> &value) { type_ = value; }

std::optional<std::vector<std::string>> Rule::getTags() const { return tags_; }

void Rule::setTags(const std::optional<std::vector<std::string>> &value) {
    tags_ = value;
}

std::optional<std::map<std::string, std::string>> Rule::getParams() const {
    return params_;
}

void Rule::setParams(
    const std::optional<std::map<std::string, std::string>> &value) {
    params_ = value;
}

std::optional<std::string> Rule::getExpr() const { return expr_; }

void Rule::setExpr(const std::optional<std::string> &value) { expr_ = value; }

std::optional<std::string> Rule::getOnSuccess() const { return onSuccess_; }

void Rule::setOnSuccess(const std::optional<std::string> &value) {
    onSuccess_ = value;
}

std::optional<std::string> Rule::getOnFailure() const { return onFailure_; }

void Rule::setOnFailure(const std::optional<std::string> &value) {
    onFailure_ = value;
}

std::optional<bool> Rule::isDisabled() const { return disabled_; }

void Rule::setDisabled(const std::optional<bool> &value) { disabled_ = value; }

}  // namespace srclient::rest::model
