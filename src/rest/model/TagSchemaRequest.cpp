/**
* Confluent Schema Registry
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: v1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "srclient/rest/model/TagSchemaRequest.h"
#include "srclient/rest/model/Helpers.h"

#include <sstream>

namespace org::openapitools::server::model
{

TagSchemaRequest::TagSchemaRequest()
{
    m_NewVersion = 0;
    m_NewVersionIsSet = false;
    m_TagsToAddIsSet = false;
    m_TagsToRemoveIsSet = false;
    m_MetadataIsSet = false;
    m_RuleSetIsSet = false;
    m_RulesToMergeIsSet = false;
    m_RulesToRemoveIsSet = false;
    
}

void TagSchemaRequest::validate() const
{
    std::stringstream msg;
    if (!validate(msg))
    {
        throw org::openapitools::server::helpers::ValidationException(msg.str());
    }
}

bool TagSchemaRequest::validate(std::stringstream& msg) const
{
    return validate(msg, "");
}

bool TagSchemaRequest::validate(std::stringstream& msg, const std::string& pathPrefix) const
{
    bool success = true;
    const std::string _pathPrefix = pathPrefix.empty() ? "TagSchemaRequest" : pathPrefix;

             
    if (tagsToAddIsSet())
    {
        const std::vector<org::openapitools::server::model::SchemaTags>& value = m_TagsToAdd;
        const std::string currentValuePath = _pathPrefix + ".tagsToAdd";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::SchemaTags& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".tagsToAdd") && success;
 
                i++;
            }
        }

    }
         
    if (tagsToRemoveIsSet())
    {
        const std::vector<org::openapitools::server::model::SchemaTags>& value = m_TagsToRemove;
        const std::string currentValuePath = _pathPrefix + ".tagsToRemove";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const org::openapitools::server::model::SchemaTags& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        success = value.validate(msg, currentValuePath + ".tagsToRemove") && success;
 
                i++;
            }
        }

    }
                     
    if (rulesToRemoveIsSet())
    {
        const std::vector<std::string>& value = m_RulesToRemove;
        const std::string currentValuePath = _pathPrefix + ".rulesToRemove";
                
        
        { // Recursive validation of array elements
            const std::string oldValuePath = currentValuePath;
            int i = 0;
            for (const std::string& value : value)
            { 
                const std::string currentValuePath = oldValuePath + "[" + std::to_string(i) + "]";
                        
        
 
                i++;
            }
        }

    }
    
    return success;
}

bool TagSchemaRequest::operator==(const TagSchemaRequest& rhs) const
{
    return
    
    
    
    ((!newVersionIsSet() && !rhs.newVersionIsSet()) || (newVersionIsSet() && rhs.newVersionIsSet() && getNewVersion() == rhs.getNewVersion())) &&
    
    
    ((!tagsToAddIsSet() && !rhs.tagsToAddIsSet()) || (tagsToAddIsSet() && rhs.tagsToAddIsSet() && getTagsToAdd() == rhs.getTagsToAdd())) &&
    
    
    ((!tagsToRemoveIsSet() && !rhs.tagsToRemoveIsSet()) || (tagsToRemoveIsSet() && rhs.tagsToRemoveIsSet() && getTagsToRemove() == rhs.getTagsToRemove())) &&
    
    
    ((!metadataIsSet() && !rhs.metadataIsSet()) || (metadataIsSet() && rhs.metadataIsSet() && getMetadata() == rhs.getMetadata())) &&
    
    
    ((!ruleSetIsSet() && !rhs.ruleSetIsSet()) || (ruleSetIsSet() && rhs.ruleSetIsSet() && getRuleSet() == rhs.getRuleSet())) &&
    
    
    ((!rulesToMergeIsSet() && !rhs.rulesToMergeIsSet()) || (rulesToMergeIsSet() && rhs.rulesToMergeIsSet() && getRulesToMerge() == rhs.getRulesToMerge())) &&
    
    
    ((!rulesToRemoveIsSet() && !rhs.rulesToRemoveIsSet()) || (rulesToRemoveIsSet() && rhs.rulesToRemoveIsSet() && getRulesToRemove() == rhs.getRulesToRemove()))
    
    ;
}

bool TagSchemaRequest::operator!=(const TagSchemaRequest& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const TagSchemaRequest& o)
{
    j = nlohmann::json::object();
    if(o.newVersionIsSet())
        j["newVersion"] = o.m_NewVersion;
    if(o.tagsToAddIsSet() || !o.m_TagsToAdd.empty())
        j["tagsToAdd"] = o.m_TagsToAdd;
    if(o.tagsToRemoveIsSet() || !o.m_TagsToRemove.empty())
        j["tagsToRemove"] = o.m_TagsToRemove;
    if(o.metadataIsSet())
        j["metadata"] = o.m_Metadata;
    if(o.ruleSetIsSet())
        j["ruleSet"] = o.m_RuleSet;
    if(o.rulesToMergeIsSet())
        j["rulesToMerge"] = o.m_RulesToMerge;
    if(o.rulesToRemoveIsSet() || !o.m_RulesToRemove.empty())
        j["rulesToRemove"] = o.m_RulesToRemove;
    
}

void from_json(const nlohmann::json& j, TagSchemaRequest& o)
{
    if(j.find("newVersion") != j.end())
    {
        j.at("newVersion").get_to(o.m_NewVersion);
        o.m_NewVersionIsSet = true;
    } 
    if(j.find("tagsToAdd") != j.end())
    {
        j.at("tagsToAdd").get_to(o.m_TagsToAdd);
        o.m_TagsToAddIsSet = true;
    } 
    if(j.find("tagsToRemove") != j.end())
    {
        j.at("tagsToRemove").get_to(o.m_TagsToRemove);
        o.m_TagsToRemoveIsSet = true;
    } 
    if(j.find("metadata") != j.end())
    {
        j.at("metadata").get_to(o.m_Metadata);
        o.m_MetadataIsSet = true;
    } 
    if(j.find("ruleSet") != j.end())
    {
        j.at("ruleSet").get_to(o.m_RuleSet);
        o.m_RuleSetIsSet = true;
    } 
    if(j.find("rulesToMerge") != j.end())
    {
        j.at("rulesToMerge").get_to(o.m_RulesToMerge);
        o.m_RulesToMergeIsSet = true;
    } 
    if(j.find("rulesToRemove") != j.end())
    {
        j.at("rulesToRemove").get_to(o.m_RulesToRemove);
        o.m_RulesToRemoveIsSet = true;
    } 
    
}

int32_t TagSchemaRequest::getNewVersion() const
{
    return m_NewVersion;
}
void TagSchemaRequest::setNewVersion(int32_t const value)
{
    m_NewVersion = value;
    m_NewVersionIsSet = true;
}
bool TagSchemaRequest::newVersionIsSet() const
{
    return m_NewVersionIsSet;
}
void TagSchemaRequest::unsetNewVersion()
{
    m_NewVersionIsSet = false;
}
std::vector<org::openapitools::server::model::SchemaTags> TagSchemaRequest::getTagsToAdd() const
{
    return m_TagsToAdd;
}
void TagSchemaRequest::setTagsToAdd(std::vector<org::openapitools::server::model::SchemaTags> const& value)
{
    m_TagsToAdd = value;
    m_TagsToAddIsSet = true;
}
bool TagSchemaRequest::tagsToAddIsSet() const
{
    return m_TagsToAddIsSet;
}
void TagSchemaRequest::unsetTagsToAdd()
{
    m_TagsToAddIsSet = false;
}
std::vector<org::openapitools::server::model::SchemaTags> TagSchemaRequest::getTagsToRemove() const
{
    return m_TagsToRemove;
}
void TagSchemaRequest::setTagsToRemove(std::vector<org::openapitools::server::model::SchemaTags> const& value)
{
    m_TagsToRemove = value;
    m_TagsToRemoveIsSet = true;
}
bool TagSchemaRequest::tagsToRemoveIsSet() const
{
    return m_TagsToRemoveIsSet;
}
void TagSchemaRequest::unsetTagsToRemove()
{
    m_TagsToRemoveIsSet = false;
}
org::openapitools::server::model::Metadata TagSchemaRequest::getMetadata() const
{
    return m_Metadata;
}
void TagSchemaRequest::setMetadata(org::openapitools::server::model::Metadata const& value)
{
    m_Metadata = value;
    m_MetadataIsSet = true;
}
bool TagSchemaRequest::metadataIsSet() const
{
    return m_MetadataIsSet;
}
void TagSchemaRequest::unsetMetadata()
{
    m_MetadataIsSet = false;
}
org::openapitools::server::model::RuleSet TagSchemaRequest::getRuleSet() const
{
    return m_RuleSet;
}
void TagSchemaRequest::setRuleSet(org::openapitools::server::model::RuleSet const& value)
{
    m_RuleSet = value;
    m_RuleSetIsSet = true;
}
bool TagSchemaRequest::ruleSetIsSet() const
{
    return m_RuleSetIsSet;
}
void TagSchemaRequest::unsetRuleSet()
{
    m_RuleSetIsSet = false;
}
org::openapitools::server::model::RuleSet TagSchemaRequest::getRulesToMerge() const
{
    return m_RulesToMerge;
}
void TagSchemaRequest::setRulesToMerge(org::openapitools::server::model::RuleSet const& value)
{
    m_RulesToMerge = value;
    m_RulesToMergeIsSet = true;
}
bool TagSchemaRequest::rulesToMergeIsSet() const
{
    return m_RulesToMergeIsSet;
}
void TagSchemaRequest::unsetRulesToMerge()
{
    m_RulesToMergeIsSet = false;
}
std::vector<std::string> TagSchemaRequest::getRulesToRemove() const
{
    return m_RulesToRemove;
}
void TagSchemaRequest::setRulesToRemove(std::vector<std::string> const& value)
{
    m_RulesToRemove = value;
    m_RulesToRemoveIsSet = true;
}
bool TagSchemaRequest::rulesToRemoveIsSet() const
{
    return m_RulesToRemoveIsSet;
}
void TagSchemaRequest::unsetRulesToRemove()
{
    m_RulesToRemoveIsSet = false;
}


} // namespace org::openapitools::server::model

