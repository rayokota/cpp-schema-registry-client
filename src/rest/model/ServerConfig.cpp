/**
* Confluent Schema Registry
* No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
*
* The version of the OpenAPI document: v1
* 
*
* NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
* https://openapi-generator.tech
* Do not edit the class manually.
*/


#include "srclient/rest/model/ServerConfig.h"

#include <sstream>

namespace srclient::rest::model
{

NLOHMANN_JSON_SERIALIZE_ENUM(CompatibilityLevel, {
    {CompatibilityLevel::Backward, "BACKWARD"},
    {CompatibilityLevel::BackwardTransitive, "BACKWARD_TRANSITIVE"},
    {CompatibilityLevel::Forward, "FORWARD"},
    {CompatibilityLevel::ForwardTransitive, "FORWARD_TRANSITIVE"},
    {CompatibilityLevel::Full, "FULL"},
    {CompatibilityLevel::FullTransitive, "FULL_TRANSITIVE"},
    {CompatibilityLevel::None, "NONE"}
})

ServerConfig::ServerConfig()
{
    // Optional members are initialized to std::nullopt by default
}

bool ServerConfig::operator==(const ServerConfig& rhs) const
{
    return
        m_Compatibility == rhs.m_Compatibility&&
        m_CompatibilityLevel == rhs.m_CompatibilityLevel &&
        m_Alias == rhs.m_Alias &&
        m_Normalize == rhs.m_Normalize &&
        m_ValidateFields == rhs.m_ValidateFields &&
        m_ValidateRules == rhs.m_ValidateRules &&
        m_CompatibilityGroup == rhs.m_CompatibilityGroup &&
        m_DefaultMetadata == rhs.m_DefaultMetadata &&
        m_OverrideMetadata == rhs.m_OverrideMetadata &&
        m_DefaultRuleSet == rhs.m_DefaultRuleSet &&
        m_OverrideRuleSet == rhs.m_OverrideRuleSet;
}

bool ServerConfig::operator!=(const ServerConfig& rhs) const
{
    return !(*this == rhs);
}

void to_json(nlohmann::json& j, const ServerConfig& o)
{
    j = nlohmann::json::object();
    if(o.m_Compatibility.has_value())
        j["compatibility"] = o.m_Compatibility.value();
    if(o.m_CompatibilityLevel.has_value())
        j["compatibilityLevel"] = o.m_CompatibilityLevel.value();
    if(o.m_Alias.has_value())
        j["alias"] = o.m_Alias.value();
    if(o.m_Normalize.has_value())
        j["normalize"] = o.m_Normalize.value();
    if(o.m_ValidateFields.has_value())
        j["validateFields"] = o.m_ValidateFields.value();
    if(o.m_ValidateRules.has_value())
        j["validateRules"] = o.m_ValidateRules.value();
    if(o.m_CompatibilityGroup.has_value())
        j["compatibilityGroup"] = o.m_CompatibilityGroup.value();
    if(o.m_DefaultMetadata.has_value())
        j["defaultMetadata"] = o.m_DefaultMetadata.value();
    if(o.m_OverrideMetadata.has_value())
        j["overrideMetadata"] = o.m_OverrideMetadata.value();
    if(o.m_DefaultRuleSet.has_value())
        j["defaultRuleSet"] = o.m_DefaultRuleSet.value();
    if(o.m_OverrideRuleSet.has_value())
        j["overrideRuleSet"] = o.m_OverrideRuleSet.value();
}

void from_json(const nlohmann::json& j, ServerConfig& o)
{
    if(j.find("compatibility") != j.end())
    {
        CompatibilityLevel temp;
        j.at("compatibility").get_to(temp);
        o.m_Compatibility= temp;
    }
    if(j.find("compatibilityLevel") != j.end())
    {
        CompatibilityLevel temp;
        j.at("compatibilityLevel").get_to(temp);
        o.m_CompatibilityLevel = temp;
    }
    if(j.find("alias") != j.end())
    {
        std::string temp;
        j.at("alias").get_to(temp);
        o.m_Alias = temp;
    } 
    if(j.find("normalize") != j.end())
    {
        bool temp;
        j.at("normalize").get_to(temp);
        o.m_Normalize = temp;
    } 
    if(j.find("validateFields") != j.end())
    {
        bool temp;
        j.at("validateFields").get_to(temp);
        o.m_ValidateFields = temp;
    } 
    if(j.find("validateRules") != j.end())
    {
        bool temp;
        j.at("validateRules").get_to(temp);
        o.m_ValidateRules = temp;
    } 
    if(j.find("compatibilityGroup") != j.end())
    {
        std::string temp;
        j.at("compatibilityGroup").get_to(temp);
        o.m_CompatibilityGroup = temp;
    } 
    if(j.find("defaultMetadata") != j.end())
    {
        srclient::rest::model::Metadata temp;
        j.at("defaultMetadata").get_to(temp);
        o.m_DefaultMetadata = temp;
    } 
    if(j.find("overrideMetadata") != j.end())
    {
        srclient::rest::model::Metadata temp;
        j.at("overrideMetadata").get_to(temp);
        o.m_OverrideMetadata = temp;
    } 
    if(j.find("defaultRuleSet") != j.end())
    {
        srclient::rest::model::RuleSet temp;
        j.at("defaultRuleSet").get_to(temp);
        o.m_DefaultRuleSet = temp;
    } 
    if(j.find("overrideRuleSet") != j.end())
    {
        srclient::rest::model::RuleSet temp;
        j.at("overrideRuleSet").get_to(temp);
        o.m_OverrideRuleSet = temp;
    } 
}

std::optional<CompatibilityLevel> ServerConfig::getCompatibility() const
{
    return m_Compatibility;
}

void ServerConfig::setCompatibility(const std::optional<CompatibilityLevel>& value)
{
    m_Compatibility= value;
}

std::optional<CompatibilityLevel> ServerConfig::getCompatibilityLevel() const
{
    return m_CompatibilityLevel;
}

void ServerConfig::setCompatibilityLevel(const std::optional<CompatibilityLevel>& value)
{
    m_CompatibilityLevel = value;
}

std::optional<std::string> ServerConfig::getAlias() const
{
    return m_Alias;
}

void ServerConfig::setAlias(const std::optional<std::string>& value)
{
    m_Alias = value;
}

std::optional<bool> ServerConfig::isNormalize() const
{
    return m_Normalize;
}

void ServerConfig::setNormalize(const std::optional<bool>& value)
{
    m_Normalize = value;
}

std::optional<bool> ServerConfig::isValidateFields() const
{
    return m_ValidateFields;
}

void ServerConfig::setValidateFields(const std::optional<bool>& value)
{
    m_ValidateFields = value;
}

std::optional<bool> ServerConfig::isValidateRules() const
{
    return m_ValidateRules;
}

void ServerConfig::setValidateRules(const std::optional<bool>& value)
{
    m_ValidateRules = value;
}

std::optional<std::string> ServerConfig::getCompatibilityGroup() const
{
    return m_CompatibilityGroup;
}

void ServerConfig::setCompatibilityGroup(const std::optional<std::string>& value)
{
    m_CompatibilityGroup = value;
}

std::optional<srclient::rest::model::Metadata> ServerConfig::getDefaultMetadata() const
{
    return m_DefaultMetadata;
}

void ServerConfig::setDefaultMetadata(const std::optional<srclient::rest::model::Metadata>& value)
{
    m_DefaultMetadata = value;
}

std::optional<srclient::rest::model::Metadata> ServerConfig::getOverrideMetadata() const
{
    return m_OverrideMetadata;
}

void ServerConfig::setOverrideMetadata(const std::optional<srclient::rest::model::Metadata>& value)
{
    m_OverrideMetadata = value;
}

std::optional<srclient::rest::model::RuleSet> ServerConfig::getDefaultRuleSet() const
{
    return m_DefaultRuleSet;
}

void ServerConfig::setDefaultRuleSet(const std::optional<srclient::rest::model::RuleSet>& value)
{
    m_DefaultRuleSet = value;
}

std::optional<srclient::rest::model::RuleSet> ServerConfig::getOverrideRuleSet() const
{
    return m_OverrideRuleSet;
}

void ServerConfig::setOverrideRuleSet(const std::optional<srclient::rest::model::RuleSet>& value)
{
    m_OverrideRuleSet = value;
}

} // namespace srclient::rest::model

