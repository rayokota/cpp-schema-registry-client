/**
 * Confluent Schema Registry
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator
 * (https://openapi-generator.tech). https://openapi-generator.tech Do not edit
 * the class manually.
 */

#include "schemaregistry/rest/model/RegisteredSchema.h"

#include <sstream>

namespace schemaregistry::rest::model {

RegisteredSchema::RegisteredSchema() {
    // Optional members are initialized to std::nullopt by default
}

RegisteredSchema::RegisteredSchema(const std::optional<int32_t> &id,
                                   const std::optional<std::string> &guid,
                                   const std::optional<std::string> &subject,
                                   const std::optional<int32_t> &version,
                                   const Schema &schema)
    : id_(id),
      guid_(guid),
      subject_(subject),
      version_(version),
      schemaType_(schema.getSchemaType()),
      references_(schema.getReferences()),
      metadata_(schema.getMetadata()),
      ruleSet_(schema.getRuleSet()),
      schema_(schema.getSchema()) {}

bool RegisteredSchema::operator==(const RegisteredSchema &rhs) const {
    return id_ == rhs.id_ && guid_ == rhs.guid_ && subject_ == rhs.subject_ &&
           version_ == rhs.version_ && schemaType_ == rhs.schemaType_ &&
           references_ == rhs.references_ && metadata_ == rhs.metadata_ &&
           ruleSet_ == rhs.ruleSet_ && schema_ == rhs.schema_;
}

bool RegisteredSchema::operator!=(const RegisteredSchema &rhs) const {
    return !(*this == rhs);
}

void to_json(nlohmann::json &j, const RegisteredSchema &o) {
    j = nlohmann::json::object();
    if (o.id_.has_value()) j["id"] = o.id_.value();
    if (o.guid_.has_value()) j["guid"] = o.guid_.value();
    if (o.subject_.has_value()) j["subject"] = o.subject_.value();
    if (o.version_.has_value()) j["version"] = o.version_.value();
    if (o.schemaType_.has_value()) j["schemaType"] = o.schemaType_.value();
    if (o.references_.has_value()) j["references"] = o.references_.value();
    if (o.metadata_.has_value()) j["metadata"] = o.metadata_.value();
    if (o.ruleSet_.has_value()) j["ruleSet"] = o.ruleSet_.value();
    if (o.schema_.has_value()) j["schema"] = o.schema_.value();
}

void from_json(const nlohmann::json &j, RegisteredSchema &o) {
    if (j.find("id") != j.end()) {
        int32_t temp;
        j.at("id").get_to(temp);
        o.id_ = temp;
    }
    if (j.find("guid") != j.end()) {
        std::string temp;
        j.at("guid").get_to(temp);
        o.guid_ = temp;
    }
    if (j.find("subject") != j.end()) {
        std::string temp;
        j.at("subject").get_to(temp);
        o.subject_ = temp;
    }
    if (j.find("version") != j.end()) {
        int32_t temp;
        j.at("version").get_to(temp);
        o.version_ = temp;
    }
    if (j.find("schemaType") != j.end()) {
        std::string temp;
        j.at("schemaType").get_to(temp);
        o.schemaType_ = temp;
    }
    if (j.find("references") != j.end()) {
        std::vector<schemaregistry::rest::model::SchemaReference> temp;
        j.at("references").get_to(temp);
        o.references_ = temp;
    }
    if (j.find("metadata") != j.end()) {
        schemaregistry::rest::model::Metadata temp;
        j.at("metadata").get_to(temp);
        o.metadata_ = temp;
    }
    if (j.find("ruleSet") != j.end()) {
        schemaregistry::rest::model::RuleSet temp;
        j.at("ruleSet").get_to(temp);
        o.ruleSet_ = temp;
    }
    if (j.find("schema") != j.end()) {
        std::string temp;
        j.at("schema").get_to(temp);
        o.schema_ = temp;
    }
}

std::optional<int32_t> RegisteredSchema::getId() const { return id_; }

void RegisteredSchema::setId(const std::optional<int32_t> &value) {
    id_ = value;
}

std::optional<std::string> RegisteredSchema::getGuid() const { return guid_; }

void RegisteredSchema::setGuid(const std::optional<std::string> &value) {
    guid_ = value;
}

std::optional<std::string> RegisteredSchema::getSubject() const {
    return subject_;
}

void RegisteredSchema::setSubject(const std::optional<std::string> &value) {
    subject_ = value;
}

std::optional<int32_t> RegisteredSchema::getVersion() const { return version_; }

void RegisteredSchema::setVersion(const std::optional<int32_t> &value) {
    version_ = value;
}

std::optional<std::string> RegisteredSchema::getSchemaType() const {
    return schemaType_;
}

void RegisteredSchema::setSchemaType(const std::optional<std::string> &value) {
    schemaType_ = value;
}

std::optional<std::vector<schemaregistry::rest::model::SchemaReference>>
RegisteredSchema::getReferences() const {
    return references_;
}

void RegisteredSchema::setReferences(
    const std::optional<
        std::vector<schemaregistry::rest::model::SchemaReference>> &value) {
    references_ = value;
}

std::optional<schemaregistry::rest::model::Metadata>
RegisteredSchema::getMetadata() const {
    return metadata_;
}

void RegisteredSchema::setMetadata(
    const std::optional<schemaregistry::rest::model::Metadata> &value) {
    metadata_ = value;
}

std::optional<schemaregistry::rest::model::RuleSet>
RegisteredSchema::getRuleSet() const {
    return ruleSet_;
}

void RegisteredSchema::setRuleSet(
    const std::optional<schemaregistry::rest::model::RuleSet> &value) {
    ruleSet_ = value;
}

std::optional<std::string> RegisteredSchema::getSchema() const {
    return schema_;
}

void RegisteredSchema::setSchema(const std::optional<std::string> &value) {
    schema_ = value;
}

Schema RegisteredSchema::toSchema() const {
    Schema schema;
    schema.setSchemaType(schemaType_);
    schema.setReferences(references_);
    schema.setMetadata(metadata_);
    schema.setRuleSet(ruleSet_);
    schema.setSchema(schema_);
    return schema;
}

}  // namespace schemaregistry::rest::model
