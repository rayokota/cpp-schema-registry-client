/**
 * Confluent Schema Registry
 * No description provided (generated by Openapi Generator
 * https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 *
 * NOTE: This class is auto generated by OpenAPI-Generator 7.13.0.
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

#include "schemaregistry/rest/RestClient.h"

#include <cpr/cpr.h>

#include <chrono>
#include <iomanip>
#include <limits>
#include <random>
#include <sstream>
#include <thread>

namespace schemaregistry::rest {

RestClient::RestClient(std::shared_ptr<const ClientConfiguration> configuration)
    : configuration_(configuration) {}
RestClient::~RestClient() {}

std::shared_ptr<const ClientConfiguration> RestClient::getConfiguration()
    const {
    return configuration_;
}

cpr::Response RestClient::sendRequestUrls(
    const std::string &path, const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    const auto &base_urls = configuration_->getBaseUrls();

    cpr::Response last_response;  // default constructed (status_code = 0)
    for (size_t i = 0; i < base_urls.size(); ++i) {
        try {
            auto result =
                tryRequest(base_urls[i], path, method, query, headers, body);

            last_response = result;

            // If successful response or non-retriable error, return it
            if (result.status_code == 0) {
                // Network error - try next URL if available
                if (i == base_urls.size() - 1) {
                    return result;  // Last URL, return the error
                }
                continue;
            } else if (result.status_code < 400 ||
                       !isRetriable(static_cast<int>(result.status_code))) {
                return result;
            } else if (i == base_urls.size() - 1) {
                // Last URL and retriable error, return it
                return result;
            }
            // Try next URL for retriable errors
        } catch (const std::exception &e) {
            if (i == base_urls.size() - 1) {
                return last_response;
            }
            // Try next URL for exceptions
        }
    }

    // This should never be reached, but return the last response
    return last_response;
}

cpr::Response RestClient::tryRequest(
    const std::string &base_url, const std::string &path,
    const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    std::uint32_t retries = 0;
    const std::uint32_t max_retries = configuration_->getMaxRetries();
    const std::uint32_t initial_wait_ms = configuration_->getRetriesWaitMs();
    const auto max_wait_ms =
        std::chrono::milliseconds(configuration_->getRetriesMaxWaitMs());

    while (true) {
        // Use the new sendRequest method that handles authentication and
        // headers
        cpr::Response result =
            sendRequest(base_url + path, method, query, headers, body);

        // Check if we should retry
        bool should_retry = false;
        if (result.status_code == 0) {
            // Network error - always retriable
            should_retry = true;
        } else if (result.status_code >= 400) {
            should_retry = isRetriable(static_cast<int>(result.status_code));
        }

        if (!should_retry || retries >= max_retries) {
            return result;
        }

        // Apply exponential backoff with jitter
        auto backoff =
            calculateExponentialBackoff(initial_wait_ms, retries, max_wait_ms);
        std::this_thread::sleep_for(backoff);
        retries++;
    }
}

cpr::Response RestClient::sendRequest(
    const std::string &url, const std::string &method,
    const std::vector<std::pair<std::string, std::string>> &query,
    const std::map<std::string, std::string> &headers,
    const std::string &body) const {
    std::unique_lock<std::mutex> lock(session_mutex_, std::defer_lock);

    auto session = configuration_->getSession();
    if (!session) {
        session = std::make_shared<cpr::Session>();
    } else {
        lock.lock();
    }

    // Configure the shared Session for this request
    // Ensure no stale body/payload leaks into requests like GET
    session->RemoveContent();
    session->SetUrl(cpr::Url{url});

    // Set default headers including content type
    cpr::Header cpr_headers;
    cpr_headers["Content-Type"] = "application/vnd.schemaregistry.v1+json";

    // Handle authentication
    const auto basic_auth = configuration_->getBasicAuth();
    const auto bearer_token = configuration_->getBearerAccessToken();

    if (basic_auth.has_value()) {
        session->SetAuth(cpr::Authentication{basic_auth.value().first,
                                             basic_auth.value().second,
                                             cpr::AuthMode::BASIC});
    } else if (bearer_token.has_value()) {
        session->SetBearer(cpr::Bearer{bearer_token.value()});
    }

    // Add additional headers (can override defaults)
    for (const auto &kv : headers) {
        cpr_headers.insert(kv);
    }

    session->SetHeader(cpr_headers);

    // Set query parameters (supporting repeated keys)
    if (!query.empty()) {
        cpr::Parameters params{};
        for (const auto &p : query) {
            params.Add(cpr::Parameter{p.first, p.second});
        }
        session->SetParameters(params);
    }

    // Set body when applicable
    if (!body.empty() && (method == "POST" || method == "PUT" ||
                          method == "PATCH" || method == "DELETE")) {
        session->SetBody(cpr::Body{body});
    }

    // Dispatch based on method
    if (method == "GET") {
        return session->Get();
    } else if (method == "POST") {
        return session->Post();
    } else if (method == "PUT") {
        return session->Put();
    } else if (method == "PATCH") {
        return session->Patch();
    } else if (method == "DELETE") {
        return session->Delete();
    } else {
        // Unsupported method; set an error-like response
        return cpr::Response{};
    }
}

std::chrono::milliseconds RestClient::calculateExponentialBackoff(
    std::uint32_t initial_backoff_ms, std::uint32_t retry_attempts,
    std::chrono::milliseconds max_backoff) const {
    // Calculate 2^retry_attempts * initial_backoff_ms with overflow protection
    std::uint64_t backoff_ms;
    if (retry_attempts >= 32 ||
        (1ULL << retry_attempts) >
            std::numeric_limits<std::uint32_t>::max() / initial_backoff_ms) {
        // Overflow would occur, use max_backoff
        backoff_ms = static_cast<std::uint64_t>(max_backoff.count());
    } else {
        backoff_ms = static_cast<std::uint64_t>((1ULL << retry_attempts) *
                                                initial_backoff_ms);
        if (backoff_ms > static_cast<std::uint64_t>(max_backoff.count())) {
            backoff_ms = static_cast<std::uint64_t>(max_backoff.count());
        }
    }

    // Apply jitter (random factor between 0.0 and 1.0)
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<double> dist(0.0, 1.0);
    double jitter = dist(gen);

    return std::chrono::milliseconds(static_cast<long>(backoff_ms * jitter));
}

bool RestClient::isRetriable(int status_code) const {
    return status_code == 408      // REQUEST_TIMEOUT
           || status_code == 429   // TOO_MANY_REQUESTS
           || status_code == 500   // INTERNAL_SERVER_ERROR
           || status_code == 502   // BAD_GATEWAY
           || status_code == 503   // SERVICE_UNAVAILABLE
           || status_code == 504;  // GATEWAY_TIMEOUT
}

}  // namespace schemaregistry::rest